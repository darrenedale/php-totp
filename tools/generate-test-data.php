<?php

/**
 * @file generate-test-data.php
 *
 * Use oathtool (https://www.nongnu.org/oath-toolkit/oathtool.1.html) to generate test data for php-totp unit tests.
 * This most likely requires a unix-like platform
 *
 * TODO more options
 * TODO help output
 */
require_once(__DIR__ . "/../vendor/autoload.php");

use Equit\Totp\Base32;
use Equit\Totp\Base64;

/**
 * Choose one of a number of options, optionally with a weighting attached to each option.
 *
 * @param array $options The options to choose from.
 * @param array|null $weights The optional weights for each option.
 *
 * @return mixed One of the options.
 */
function chooseOne(array $options, array $weights = null): mixed
{
	if (!isset($weights)) {
		return $options[mt_rand(0, count($options) - 1)];
	}

	$item = mt_rand(0, array_sum($weights) - 1);
	$cumulativeWeight = 0;

	for ($idx = 0; $idx < count($weights); ++$idx) {
		$cumulativeWeight += $weights[$idx];

		if ($cumulativeWeight > $item) {
			break;
		}
	}

	return $options[$idx];
}

/**
 * Choose a random algorithm from those supported by TOTP.
 *
 * This will be one of sha1, sah256 and sha512.
 *
 * @return string The algorithm.
 */
function randomAlgorithm(): string
{
	return chooseOne(["SHA1", "SHA256", "SHA512",]);
}

/**
 * Generate a random timestamp to act as the reference time for the TOTP.
 *
 * The generated timestamp will be some time between the unix epoch and the current system time.
 *
 * @return int The timestamp.
 */
function randomReferenceTimestamp(): int
{
	return mt_rand(0, time() - 20 * 365 * 24 * 60 * 60);
}

/**
 * Generate a random timestamp to act as the time at which to generate the password for the TOTP.
 *
 * The timestamp will be some point between the provided reference time for the TOTP and the end of the largest year
 * provided, of 9999 if no largest year is provided.
 *
 * $maxYear must be after the year of the reference timestamp and must not be greater than 9999.
 *
 * @param int $referenceTimestamp The reference timestamp for the TOTP.
 * @param int|null $maxYear The latest year for which a random time may be generated.
 *
 * @return int
 */
function randomNow(int $referenceTimestamp, int $maxYear = null): int
{
	if (isset($maxYear)) {
		$maxTimestamp = (DateTime::createFromFormat("Y-m-d H:i:s", "{$maxYear}-12-31 23:59:59", new DateTimeZone("UTC")))->getTimestamp();
	} else {
		// 9999-12-31 23:59:59
		$maxTimestamp = 253402300799;
	}

	return mt_rand($referenceTimestamp, $maxTimestamp);
}

/**
 * Generate a random interval for a TOTP.
 *
 * The generated interval will be a multiple of 10 seconds between 10 and 3660 (one hour), inclusive.
 *
 * @return int The interval.
 */
function randomInterval(): int
{
	return 10 * mt_rand(1, 360);
}

/**
 * Generate a random number of digits for the password generated by an OTP.
 *
 * The number of digits will be 6, 7 or 8.
 *
 * @return int The number of digits.
 */
function randomDigits(): int
{
	return chooseOne([6, 7, 8,]);
}

/**
 * Convert a binary string to a PHP string literal for use in PHP source code.
 *
 * @param string $str The string to convert.
 *
 * @return string The PHP source string literal for the proviced binary string.
 */
function phpHexStringLiteral(string $str): string
{
	return "\\x" . implode("\\x", str_split(bin2hex($str), 2));
}

$opts = [
	"secret-type" => "base32",
	"times" => 1,
];

for ($idx = 1; $idx < $argc; ++$idx) {
	switch ($argv[$idx]) {
		case "--secret":
			$opts["secret"] = $argv[++$idx] ?? die("--secret requires the secret to be specified as the next argument.");
			break;

		case "--times":
			++$idx;

			if (!isset($argv[$idx])) {
				die("--times requires the number of test data items to be specified as the next argument.");
			}

			if (!filter_var($argv[$idx], FILTER_VALIDATE_INT, ["options" => ["min_range" => 1,],])) {
				die("The number of test data items must be a positive integer.");
			}

			$opts["times"] = intval($argv[$idx]);
			break;

		case "-32":
			$opts["secret-type"] = "base32";
			break;

		case "-64":
			$opts["secret-type"] = "base64";
			break;

		default:
			die ("Unrecognised argument {$argv[$idx]}.");
	}
}

if (isset($opts["secret"])) {
	$opts["secret"] = match($opts["secret-type"]) {
		"base32" => $opts["secret"],
		"base64" => Base32::encode(Base64::decode($opts["secret"])),
		"hex" => Base32::encode(hex2bin($opts["secret"])),
	};
}

echo "[\n";

$timesDigits = strlen("{$opts["times"]}");

for ($idx = 0; $idx < $opts["times"]; ++$idx) {
	$secret = $opts["secret"] ?? Base32::encode(random_bytes(20));
	$algorithm = $opts["algorithm"] ?? randomAlgorithm();
	$referenceTimestamp = $opts["referenceTimestamp"] ?? randomReferenceTimestamp();
	$interval = $opts["interval"] ?? randomInterval();
	$digits = $opts["digits"] ?? randomDigits();
	$nowTimestamp = $opts["now"] ?? randomNow($referenceTimestamp, 2299);
	$referenceTime = new DateTime("@{$referenceTimestamp}", new DateTimeZone("UTC"));
	$nowTime = new DateTime("@{$nowTimestamp}", new DateTimeZone("UTC"));
	$oathToolOutput = explode("\n", trim(`oathtool -b -v --totp={$algorithm} -d {$digits} --now "{$nowTime->format("Y-m-d H:i:s")} UTC" -s {$interval}s -S "{$referenceTime->format("Y-m-d H:i:s")} UTC" "{$secret}"`));
	$password = array_pop($oathToolOutput);

	foreach ($oathToolOutput as $line) {
		if (preg_match("/Counter: 0x([a-zA-Z0-9]+) \(([0-9]+)\)/", $line, $matches)) {
			$counterValue = intval($matches[2]);
			$counterBytes = hex2bin(str_pad($matches[1], 16, "0", STR_PAD_LEFT));
		}
	}

	echo "   \"randomDataset" . sprintf("%0{$timesDigits}d", $idx + 1) . "\" => [\n";
	echo "      \"algorithm\" => \"" . strtolower($algorithm) . "\"\n";
	echo "      \"secret\" => [\n";
	echo "         \"raw\" => \"" . phpHexStringLiteral(Base32::decode($secret)) . "\"\n";
	echo "         \"base32\" => \"{$secret}\"\n";
	echo "         \"base64\" => \"" . Base64::encode(Base32::decode($secret)) . "\"\n";
	echo "      ],\n";
	echo "      \"referenceTime\" => [\n";
	echo "         // {$referenceTime->format("Y-m-d H:i:s")} UTC\n";
	echo "         \"timestamp\" => {$referenceTimestamp},\n";
	echo "         \"datetime\" => new DateTime(\"@{$referenceTimestamp}\", new DateTimeZone(\"UTC\")),\n";
	echo "      ],\n";
	echo "      \"interval\" => {$interval},\n";
	echo "      \"currentTime\" => [\n";
	echo "         // {$nowTime->format("Y-m-d H:i:s")} UTC\n";
	echo "         \"timestamp\" => {$nowTimestamp},\n";
	echo "         \"datetime\" => new DateTime(\"@{$nowTimestamp}\", new DateTimeZone(\"UTC\")),\n";
	echo "      ],\n";
	echo "      \"digits\" => {$digits},\n";
	echo "      \"counter\" => [\n";
	echo "         \"bytes\" => \"" . phpHexStringLiteral($counterBytes) . "\",\n";
	echo "         \"value\" => {$counterValue},\n";
	echo "      ],\n";
	echo "      \"password\" => \"{$password}\",\n";
	echo "   ],\n";
}

echo "]\n";